### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

```javascript
var canJump = function(nums) {
        let k = 0;
        for (let i = 0; i < nums.length; i++) {
            if (i > k) return false;
            k = Math.max(k, i + nums[i]);
        }
        return true;

};
```

### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

```javascript
var jump = function(nums) {
    let ans = 0;
    let end = 0;
    let maxPos = 0;
    for (let i = 0; i < nums.length - 1; i++)
    {
        maxPos = Math.max(nums[i] + i, maxPos);
        if (i == end)
        {
            end = maxPos;
            ans++;
        }
    }
    return ans;
};
```

### [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

```javascript
var merge = function(nums1, m, nums2, n) {
      let p1 = m-1
    let p2 = n-1
    let k = m+n-1

    while(p1 >= 0 || p2>=0){
        if(nums2[p2] === undefined || nums1[p1] >= nums2[p2] ){
            nums1[k] =nums1[p1] 
            p1--
        }else{
            nums1[k] = nums2[p2]
            p2--
        }
        k--
    }


};
```

### [27. 移除元素](https://leetcode.cn/problems/remove-element/)

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```
var removeElement = function(nums, val) {
let p = 0;
    for(let i=0; i<nums.length; i++){
        if(nums[i] !== val){
            nums[p] = nums[i];
            p++
        }
    }
    return p;
};
```

### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

```javascript
var removeDuplicates = function(nums) {
    let dict = {}
    let cur = 0
    for(let i=0; i<nums.length; i++){
        if(dict[nums[i]] === undefined){
           dict[nums[i]] = null
           nums[cur] = nums[i]
           cur++ 
        }
    }
    return cur
};
```

### [80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

```javascript
var removeDuplicates = function(nums) {
     const dict = {}
    let cur 
    for(let i=0; i<nums.length; i++){
        const item =nums[i]
        if( dict[nums[i]] === undefined ||  dict[nums[i]] <=1){
            dict[nums[i]] =  dict[nums[i]] === undefined ? 1 :  dict[nums[i]] + 1
            if(cur !== undefined){
                nums[cur] = nums[i]
                cur++
            }
        }else{
            if(cur === undefined){
                cur = i
            }
        }
    }

    return cur

};
```

