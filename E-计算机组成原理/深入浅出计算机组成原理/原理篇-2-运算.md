### 一、二进制编码

#### 1.理解二进制的“逢二进一”

十进制转二进制用**短除法**。

##### 负数表示

###### 1.原码表示法：

个 4 位的二进制数， 0011 就表示为 +3。而 1011 最左侧的第一位是 1，所以它就表示 -3。这个其实就是整数的原码表示法。

> 原码表示法有一个很直观的缺点就是，0 可以用两个不同的编码来表示，1000 代表 0， 0000 也代表 0。习惯万事一一对应的程序员看到这种情况，必然会被“逼死”。

###### 2.补码

通过最左侧第一位的 0 和 1，来判断这个数的正负。但不再把这一位当成单独的符号位，在剩下几位计算出的十进制前加上正负号，而是在计算整个二进制值的时候，在左侧最高位前面加个负号。

> 比如，一个 4 位的二进制补码数值 1011，转换成十进制，就是 −1×23+0×22+1×21+1×20=−5。如果最高位是 1，这个数必然是负数；最高位是 0，必然是正数。并且，只有 0000 表示 0，1000 在这样的情况下表示 -8。一个 4 位的二进制数，可以表示从 -8 到 7 这 16 个整数，不会白白浪费一位。

当然更重要的一点是，用补码来表示负数，使得我们的整数相加变得很容易，不需要做任何特殊处理，只是把它当成普通的二进制相加，就能得到正确的结果。

#### 2.字符互的表示，从编码到数字

##### 1.ASCII 码

>  American Standard Code for Information Interchange，美国信息交换标准代码

![image-20210619091440571](../../image/image-20210619091440571.png)

> ASCII 码就好比一个字典，用 **8 位二进制中的 128 个不同的数**，映射到 128 个不同的字符里。
>
> 在 ASCII 码里面，数字 9 不再像整数表示法里一样，用 0000 1001 来表示，而是用 0011 1001 来表示。字符串 15 也不是用 0000 1111 这 8 位来表示，而是变成两个字符 1 和 5 连续放在一起，也就是 0011 0001 和 0011 0101，需要用两个 8 位来表示。 2
>
> **因为9的ASCII码是0039，换算成二进制，就是0011 1001了**

##### 2.不管是整数也好，浮点数也好，采用二进制序列化会比存储文本省下不少空间。

最大的 32 位整数，就是 2147483647。如果用整数表示法，只需要 32 位就能表示了。但是如果用字符串来表示，一共有 10 个字符，每个字符用 8 位的话，需要整整 80 位。比起整数表示法，要多占很多空间。

##### 3.字符集（Charset）和字符编码（Character Encoding）

###### 字符集

字符集，表示的可以是字符的一个集合。我们日常说的 Unicode，其实就是一个字符集，包含了 150 种语言的 14 万个不同的字符。

> 比如“中文”就是一个字符集，不过这样描述一个字符集并不准确。想要更精确一点，我们可以说，“第一版《新华字典》里面出现的所有汉字”，这是一个字符集。这样，我们才能明确知道，一个字符在不在这个集合里面。

###### **字符编码**

而字符编码则是对于字符集里的这些字符，怎么一一用二进制表示出来的一个字典。

>  Unicode字符集，就可以用 UTF-8、UTF-16，乃至 UTF-32 来进行编码，存储成二进制。有了 Unicode，其实可以用不止 UTF-8 一种编码形式，也可以自己发明一套 GT-32 编码，比如就叫作 Geek Time 32 好了。只要别人知道这套编码规则，就可以正常传输、显示这段代码。

##### **4.中文乱码**

在中文世界里，最典型的就是“手持两把锟斤拷，口中疾呼烫烫烫”的典故。

“锟斤拷”来源，如果想要用 Unicode 编码记录一些文本，但这些字符在 Unicode 中可能并不存在。于是，Unicode 会统一把这些字符记录为 U+FFFD 这个编码。如果用 UTF-8 的格式存储下来，就是\xef\xbf\xbd。如果连续两个这样的字符放在一起，\xef\xbf\xbd\xef\xbf\xbd，这个时候，如果程序把这个字符，用 GB2312 的方式进行 decode，就会变成“锟斤拷”。这就好比我们用 GB2312 这本密码本，去解密别人用 UTF-8 加密的信息，自然没办法读出有用的信息。

而“烫烫烫”，则是因为如果你用了 Visual Studio 的调试器，默认使用 MBCS 字符集。“烫”在里面是由 0xCCCC 来表示的，而 0xCC 又恰好是未初始化的内存的赋值。于是，在读到没有赋值的内存地址或者变量的时候，电脑就开始大叫“烫烫烫”了。

### 二、理解电路

#### 1.从信使到电报，我们怎么做到“其那里传书”？

1. 靠人传口或者送信，速度慢

2. “击鼓进军”和“鸣金收兵”，效率高，但传递范围有限

3. 海上灯塔、长城烽火台，因为光比声速更快，传的距离更远，不能传太复杂的信息

4. 电报传输的信号有两种，一种是短促的点信号（dot 信号），一种是长一点的划信号（dash 信号）。

   > 电影里最常见的电报信号是“SOS”，这个信号表示出来就是 “点点点划划划点点点”。

电报机本质上就是一个“蜂鸣器 + 长长的电线 + 按钮开关”。

>  蜂鸣器装在接收方手里，开关留在发送方手里。双方用长长的电线连在一起。当按钮开关按下的时候，电线的电路接通了，蜂鸣器就会响。短促地按下，就是一个短促的点信号；按的时间稍微长一些，就是一个稍长的划信号。
>
> 摩尔斯电码发报机



![image-20210619111757082](../../image/image-20210619111757082.png)

#### 2.理解继电器，给跑不动的信号续一秒

随着电线的线路越长，电线的电阻就越大。当电阻很大，而电压不够的时候，即使按下开关，蜂鸣器也不会响。

继电器

![image-20220421232518384](../../image/image-20220421232518384.png)

中继，其实就是不短地通过新的电源重新放大已经开始衰减的原有信号

>  继电器也叫电驿，这个接力的策略不仅可以用在电报中，也可以用在通信类的科技产品中如 “中继”的WiFi 路由器，光信号传输中信号放大信号的中继。

有了继电器之后，不仅有了一个能接力传输信号的方式，更重要的是和输入端通过开端的“开”和“关”来表示“1”和“0”一样，在输入端也能表示“1”和“0”了。

##### 与（AND）

在输入端的电路上，提供串联的两个开关，只有两个开关都打开，电路才接通，输出开关也才能接通，这其实就是模拟了计算机里面的“与”操作。

##### 或 （OR）

在输入端的电路，提供两条独立的线路到输出端，两条线路上各有一个开关，那么任何一个开关打开了，到输出端的电路都是接通的，这其实就是模拟了计算机中的“或”操作。

##### 非 （NOT）

把输出端的“螺旋线圈+磁性开关”的组合，从默认关掉，只有通电有了磁场之后打开，换成默认是打开通电的，只有通电之后才关闭，就得到了一个计算机中的“非”操作。输出端开和关正好和输入端相反。这个在数字电路中，也叫作反向器（Inverter）。

![image-20220421234141832](../../image/image-20220421234141832.png)

反向器的电路，其实就是开关从默认关闭变成默认开启而已。

与、或、非的电路都非常简单，要想做稍微复杂一点的工作，就需要很多电路的组合。不过，这也彰显了现代计算机体系中一个重要的思想，就是通过分层和组合，逐步搭建起更加强大的功能。

#### 3.推荐阅读

《编码：隐匿在计算机软硬件背后的语言》的第 6～11 章，是一个很好的入门材料，可以帮助你深入理解数字电路，值得你花时间好好读一读。

> 除了与、或、非之外，还有很多基础的门电路，比如“异或（XOR）门”。你可以想一想，试着搜索一些资料，设计一个异或门的电路。















