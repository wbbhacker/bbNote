### OAuth2.0

OAuth 2.0 是一种相对复杂繁琐的认证授权协议。它是在RFC 6749中定义的国际标准，RFC 6749 正文的第一句就阐明了 OAuth 2.0 是面向于解决第三方应用（Third-Party Application）的认证授权协议。

> 如果你的系统并不涉及到第三方，既不为第三方提供服务，也不使用第三方的服务，那引入 OAuth 2.0 其实就没必要。
>
> 密码泄露、授权范围、授权回收

OAuth 2.0 以令牌（Token）代替用户密码作为授权的凭证。

#### 1.OAuth2.0 关键术语

<img src="../../image/image-20230810192248904.png" alt="image-20230810192248904" style="zoom:50%;" />

- 第三方应用（Third-Party Application）：需要得到授权访问我资源的那个应用，即此场景中的“Travis-CI”。
- 授权服务器（Authorization Server）：能够根据我的意愿提供授权（授权之前肯定已经进行了必要的认证过程，但它与授权可以没有直接关系）的服务器，即此场景中的“GitHub”。
- 资源服务器（Resource Server）：能够提供第三方应用所需资源的服务器，它与认证服务可以是相同的服务器，也可以是不同的服务器，即此场景中的“我的代码仓库”。
- 资源所有者（Resource Owner）： 拥有授权权限的人，即此场景中的“我”。
- 操作代理（User Agent）：指用户用来访问服务器的工具，对于人类用户来说，这个通常是指浏览器。但在微服务中，一个服务经常会作为另一个服务的用户，此时指的可能就是 HttpClient、RPCClient 或者其他访问途径。

#### 2.四种授权方式

##### 1.授权码模式

授权码模式 （Authorization Code）是四种模式中最严（luō）谨（suō）的，它考虑到了几乎所有敏感信息泄露的预防和后果。

<img src="../../image/image-20230810194055021.png" alt="image-20230810194055021" style="zoom:50%;" />

在开始进行授权过程之前，第三方应用要先到授权服务器上进行注册。所谓的注册，是指第三方应用向认证服务器提供一个域名地址，然后从授权服务器中获取 ClientID 和 ClientSecret。

1. 第三方应用将资源所有者（用户）导向授权服务器的授权页面，并向授权服务器提供 ClientID 及用户同意授权后的回调 URI，这是第一次客户端页面转向。
2. 授权服务器根据 ClientID 确认第三方应用的身份，用户在授权服务器中决定是否同意向该身份的应用进行授权。注意，用户认证的过程未定义在此步骤中，在此之前就应该已经完成。
3. 如果用户同意授权，授权服务器将转向第三方应用在第 1 步调用中提供的回调 URI，并附带上一个授权码和获取令牌的地址作为参数，这是第二次客户端页面转向。
4. 第三方应用通过回调地址收到授权码，然后将授权码与自己的 ClientSecret 一起作为参数，通过服务器向授权服务器提供的获取令牌的服务地址发起请求，换取令牌。该服务器的地址应该与注册时提供的域名处于同一个域中。
5. 授权服务器核对授权码和 ClientSecret，确认无误后，向第三方应用授予令牌。令牌可以是一个或者两个，其中必定要有的是访问令牌（Access Token），可选的是刷新令牌（Refresh Token）。访问令牌用于到资源服务器获取资源，有效期较短，刷新令牌用于在访问令牌失效后重新获取，有效期较长。
6. 资源服务器根据访问令牌所允许的权限，向第三方应用提供资源。

> 微信网页H5 授权就是一个很好的例子，H5即为第三方应用，操作代理为浏览器，资源所有者为本人。

**会不会有其他应用冒充第三方应用骗取授权？**

ClientID 代表一个第三方应用的“用户名”，这项信息是可以完全公开的。但 ClientSecret 应当只有应用自己才知道，这个代表了第三方应用的“密码”。在第 5 步发放令牌时，调用者必须能够提供 ClientSecret 才能成功完成。只要第三方应用妥善保管好 ClientSecret，就没有人能够冒充它。

**为什么要先发放授权码，再用授权码换令牌？**

这是因为客户端转向（通常就是一次 HTTP 302 重定向）对于用户是可见的。换言之，授权码可能会暴露给用户以及用户机器上的其他程序，但由于用户并没有 ClientSecret，光有授权码也无法换取到令牌，所以就避免了令牌在传输转向过程中被泄漏的风险。

**为什么要设计一个时限较长的刷新令牌和时限较短的访问令牌？不能直接把访问令牌的时间调长吗？**

这是为了缓解 OAuth 2.0 在实际应用中的一个主要缺陷。因为通常情况下，访问令牌一旦发放，除非超过了令牌中的有效期，否则很难有其他方式让它失效。所以访问令牌的时效性一般会设计得比较短，比如几个小时，如果还需要继续用，那就定期用刷新令牌去更新，授权服务器可以在更新过程中决定是否还要继续给予授权。

尽管授权码模式是很严谨的，但它并不够好用，这不仅仅体现在它那繁复的调用过程上，还体现在它对第三方应用提出了一个“貌似不难”的要求：第三方应用必须有应用服务器，因为第 4 步要发起服务端转向，而且要求服务端的地址必须与注册时提供的地址在同一个域内。

除了基于浏览器的应用外，现在越来越普遍的是移动或桌面端的客户端 Web 应用（Client-Side Web Applications），比如现在大量的基于 Cordova、Electron、Node-Webkit.js 的PWA 应用，它们都不会有应用服务器的支持。

正是因为有这样的实际需求，就引出了 OAuth 2.0 的第二种授权模式：隐式授权。

##### 2.简化模式

隐式授权（Implicit）省略掉了通过授权码换取令牌的步骤，整个授权过程都不需要服务端的支持，一步到位。而使用的代价是在隐式授权中，授权服务器不会再去验证第三方应用的身份，因为已经没有应用服务器了，ClientSecret 没有人保管，就没有存在的意义了。

但隐式授权中的授权服务器，还是会限制第三方应用的回调 URI 地址必须与注册时提供的域名一致，且 同样基于安全考虑，在隐式模式中也明确禁止发放刷新令牌，并且通过 Fragment 带回。虽然有可能会被 DNS 污染之类的攻击所攻破，但这也算是它尽可能地努力了一下吧。同样的原因，隐式授权也不能避免令牌暴露给资源所有者，不能避免用户机器上可能意图不轨的其他程序、HTTP 的中间人攻击等风险。

<img src="../../image/image-20230810201430689.png" alt="image-20230810201430689" style="zoom:50%;" />

隐式模式与授权码模式的显著区别是授权服务器在得到用户授权后，直接返回了访问令牌。

> http://localhost/#/detail/1
>
> 后面的 /detail/1 便是 Fragment，这个语法是在RFC 3986中定义的。该规范中解释了这是用于客户端定位的 URI 从属资源，比如在 HTML 中，就可以使用 Fragment 来做文档内的跳转而不会发起服务端请求。
>
> 此外，RFC 3986 还规定了，如果浏览器对一个带有 Fragment 的地址发出 Ajax 请求，那 Fragment 是不会跟随请求被发送到服务端的，只能在客户端通过 Script 脚本来读取。
>
> 所以，隐式授权巧妙地利用这个特性，尽最大努力地避免了令牌从操作代理到第三方服务之间的链路，存在被攻击而泄露出去的可能性。

至于认证服务器到操作代理之间的这一段链路的安全，则只能通过 TLS（即 HTTPS）来保证不会受到中间人攻击了，我们可以要求认证服务器必须都是启用 HTTPS 的，但无法要求第三方应用同样都支持 HTTPS。



##### 3.密码模式

授权码模式和隐式模式都属于纯粹的授权模式，它们与认证没有直接的联系，如何认证用户的真实身份，跟如何进行授权是两个互相独立的过程。但在密码模式（Resource Owner Password Credentials）里，认证和授权就被整合成了同一个过程。

密码模式原本的设计意图是，仅限于在用户对第三方应用是高度可信任的场景中使用，因为用户需要把密码明文提供给第三方应用，第三方以此向授权服务器获取令牌。



这种高度可信的第三方是非常罕见的，尽管在介绍 OAuth 2.0 的材料中，经常举的例子是“操作系统作为第三方应用向授权服务器申请资源”，但真实应用中极少遇到这样的情况，合理性依然十分有限。

我认为，如果要采用密码模式，那“第三方”属性就必须弱化，把“第三方”看作是系统中与授权服务器相对独立的子模块，在物理上独立于授权服务器部署，但是在逻辑上与授权服务器仍同属一个系统。这样把认证和授权一并完成的密码模式，才会有合理的应用场景。

<img src="../../image/image-20230810202322469.png" alt="image-20230810202322469" style="zoom:50%;" />

在密码模式下，“如何保障安全”的职责无法由 OAuth 2.0 来承担，只能由用户和第三方应用来自行保障，尽管 OAuth 2.0 在规范中强调到“此模式下，第三方应用不得保存用户的密码”，但这并没有任何技术上的约束力。

##### 4.客户端模式

客户端模式（Client Credentials）是四种模式中最简单的，它只涉及到两个主体：第三方应用和授权服务器。

客户端模式就是指第三方应用（考虑到前后统一，我们还是继续沿用这个称呼）以自己的名义，向授权服务器申请资源许可。这种模式通常用于管理操作或者自动处理类型的场景中。



举个具体例子。比如我开了一家叫 Fenix's Bookstore 的书店，因为小本经营，不像京东那样全国多个仓库可以调货，因此我必须保证只要客户成功购买，书店就必须有货可发，不允许超卖。但问题是，经常有顾客下了订单又拖着不付款，导致部分货物处于冻结状态。所以，Fenix's Bookstore 中有一个订单清理的定时服务，自动清理超过两分钟还未付款的订单。在这个场景里，订单肯定是属于下单用户自己的资源，如果把订单清理服务看作是一个独立的第三方应用的话，它是不可能向下单用户去申请授权来删掉订单的，而是应该直接以自己的名义，向授权服务器申请一个能清理所有用户订单的授权。那么这个客户端模式的时序就会是这样的：

<img src="../../image/image-20230810202642201.png" alt="image-20230810202642201" style="zoom:50%;" />

在微服务架构中，其实并不提倡同一个系统的各服务间有默认的信任关系，所以服务之间的调用也需要先进行认证授权，然后才能通讯。

那么此时，客户端模式便是一种常用的服务间认证授权的解决方案。

> 此外，在 OAuth 2.0 中呢，还有一种与客户端模式类似的授权模式，在RFC 8628中定义为“设备码模式”（Device Code）。

实际上，无论是哪一种授权模式，它们都属于保障**授权过程可靠的实现方案**。那么，系统要如何确保授权的结果可控呢。
