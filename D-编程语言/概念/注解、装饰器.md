## 装饰器和注解

装饰器和注解之前也搞不清他们的具体理念，觉得都是基于元编程实现，注解就是装饰模式的一种吧。

- **注解（Annotation）**：仅提供**附加元数据支持**，并不能实现任何操作。需要另外的 Scanner 根据元数据执行相应操作。
- **装饰器（Decorator）**：仅提**供定义劫持**，可以对类，类的方法，类的属性以及类的方法的入参进行修改。不提供元数据的支持。

### 注解与装饰器两者之间的联系：

通过注解添加元数据，然后在装饰器中获取这些元数据，完成对类、类的方法等等的修改，可以在装饰器中添加元数据的支持，比如可以可以在装饰器工厂函数以及装饰器函数中添加元数据支持等。

### 注解与装饰器的区别

虽然语法上很相似，但在不同的语言中可能使用的是不同的概念：

- **使用注解（Annotation）的语言**：AtScript、Java、C#（叫 Attribute）。
- **使用装饰器（Decorator）的语言**：Python、JavaScript/ECMAScript。

从概念上来说，我们可以很清晰的看出，注解和装饰器在语义上没有任何共性！

注解和装饰器可以互相模拟，不等同。 装饰器可以天生跑在运行时，注解还要通过反射(拿不到类型本身)

> 继承模式是丰富子元素“内涵”的一种重要方式，不管是继承接口还是子类继承基类。而装饰者模式可以在不改变继承关系的前提下，包装先有的模块，使其内涵更加丰富，并不会影响到原来的功能。与继承相比，更加的灵活。

装饰器最为强大的功能之一是它能够反射元数据（reflect metada）。

反射用于描述能够检查同一系统（或其自身）中的其他代码的代码。

[1]: https://www.zhoulujun.cn/html/webfront/ECMAScript/typescript/2020_0721_8528.html

