### 1.call

#### 1.Ecma262定义：

`Function.prototype.call ( thisArg, ...args )`：

1. Let func be the this value. 

   设目标函数func 为 this 的值

2. If [IsCallable](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-iscallable)(func) is false, throw a TypeError exception.

   调用`icCallable`函数判断判断`func` 是否可执行调用, func不能调用咋抛出错误。

   >  IsCallable ( argument ):
   >
   > 1. If argument [is not an Object](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-object-type), return false.
   > 2. If argument has a [[Call]] internal method, return true.
   > 3. Return false.

3. Perform [PrepareForTailCall](https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-preparefortailcall)().

   PrepareForTailCall 函数作用是：尾调用优化，在调用目标函数之前(即下边第4步骤)，释放当前执行上下文环境(即call函数的)相关资源。

   注意：只是释放了资源，函数调用栈的数量没变(call函数没有从调用栈中删除)。如下图

   ![image-20221012161538549](../../../image/image-20221012161538549.png)

   

4. Return ? [Call](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-call)(func, thisArg, args).

   尾调用执行目标函数func



[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#calling_slice_on_non-array_objects	"slice 截non-array 对象"
[2]: https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-function.prototype.call	"ecma262 call标准定义"
[3]: https://tc39.es/ecma262/multipage/abstract-operations.html#sec-iscallable	" isCallable"
[4]: https://stackoverflow.com/questions/50419625/do-bound-functions-support-proper-tail-calls-in-es6	"stackoverflow "

> he `PrepareForTailCall` happens in [`EvaluateDirectCall` during the evaluation of the call expression](https://www.ecma-international.org/ecma-262/6.0/index.html#sec-evaluatedirectcall), where it checks whether that expression is in a tail position. When the tail call is prepared, the current running execution context is dropped, before the function is [called](https://www.ecma-international.org/ecma-262/6.0/index.html#sec-call), dispatching on the respective `[[Call]]` internal method. The new running execution context is set up in [`PrepareForOrdinaryCall`](https://www.ecma-international.org/ecma-262/6.0/index.html#sec-prepareforordinarycall) from the [`[[Call\]]` method of user-defined functions](https://www.ecma-international.org/ecma-262/6.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist). The [`[[Call\]]` method of bound functions](https://www.ecma-international.org/ecma-262/6.0/index.html#sec-bound-function-exotic-objects-call-thisargument-argumentslist) just introduces an extra level of indirection before that happens.
>
> > In the ECMAScript 2015 Language Specification, the definitions of `Function.prototype.apply` and `Function.prototype.call` both include "*Perform `PrepareForTailCall()`*" as one of their steps, so we know that these functions support proper tail calls.
>
> The `call` and `apply` methods are functions calling functions, and when they are called there are two calls on the stack that need to be tail-call-optimised. (Contrast this to - for example - `Array.prototype.map`, which also calls other functions, but here the `map` execution context stays on the call stack. In `call` and `apply`, the `Call()` is indeed in a tail position of the algorithm).

[5]: https://262.ecma-international.org/6.0/#sec-evaluatedirectcall	"Sec-evaluatedirectcall"
[6]: https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.map	" ecma 262 map"
[7]: https://262.ecma-international.org/6.0/#sec-evaluatedirectcall	" Runtime Semantics: EvaluateDirectCall( func, thisValue, arguments, tailPosition )"
[8]: https://262.ecma-international.org/6.0/#sec-bound-function-exotic-objects-call-thisargument-argumentslist	" BoundFunctionCreate (targetFunction, boundThis, boundArgs)"

#### 2.实现

```javascript
Function.prototype._call = function (v, ...args) {
	// v 为null、undefined、非对象、转化为对象处理.代码实现省略
  // this在_call指向的是目标函数 本例指fn
  v.fn = this
  // 把this 复制给v的一个属性并执行，是改变目标函数执行时this的指向，
  // 即this指向v
  return v.fn(...args)
}
const obj = {
  name: '关注@程序员阿彬',
}
const fn = function () {
  console.log(this.name)
  console.log(arguments)
}
fn._call(obj, 1, 2)
// 打印：'关注@程序员阿彬'
// 打印：Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]
```





### 2.apply

#### 1.定义

`Function.prototype.apply ( thisArg, argArray )`

1.  Let func be the this value.

2. If [IsCallable](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-iscallable)(func) is false, throw a TypeError exception.

3. If argArray is undefined or null, then

   a. Perform [PrepareForTailCall](https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-preparefortailcall)().

   b. Return ? [Call](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-call)(func, thisArg).

   > 对`argArray` 进行判断，如果没有参数，执行跟call一样

4. Let argList be ? [CreateListFromArrayLike](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-createlistfromarraylike)(argArray).

   >  如果argArray为类数组对象，调用CreateListFromArrayLike函数把它转化为数组。argArray非数组或非类数组对象的话，会报错。
   >
   > ![image-20221012184025986](../../../image/image-20221012184025986.png)
   >
   > 类数组对象这样的 `{0:'a',1:'b',length:2}`

5. Perform [PrepareForTailCall](https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-preparefortailcall)().

6.  Return ? [Call](https://tc39.es/ecma262/multipage/abstract-operations.html#sec-call)(func, thisArg, argList).

#### 2.实现

参考call 的实现



> 注意call、apply中：
>
> 1.如果目标函数是箭头函数或者绑定了外部对象的函数，在最后一步`Call(func,thisArg,args)`时，会忽略 `thisArg` 参数。
>
> 看下图代码：
>
> ```javascript
> const obj = {
>   name: '关注@程序员阿斌',
> }
> const fn = function () {
>   console.log(this.name)
> }
> const bound_function_exotic_object = fn.bind(obj)
> //绑定了外部对象的函数
> bound_function_exotic_object.call({ name: '收藏' }) 
> // 打印：关注@程序员阿斌,绑定的对象失效
> 
> const fn1111 = () => {
>    console.log(this.name === '')
> }
> fn1111.call(obj)
> // 打印：true，绑定的对象失效
> ```
>
> 2.`thisArg` 为`null`、`undefined`时，`thisArg`会被赋值为全局对象。 非对象String、Boolean、Number、BigInt、Symbol会被转化成对应的对象类型（如： a new Boolean object）。



isCallable、PrepareForTailCall 具体执行过程，见参考链接。

既然谈到了尾调用优化，下一篇开js技术方面中的第一个系列： “js性能优化系列” ，以后遇到js性能优化方面内容，会一直更新这个系列。下下期再会接着讲bind 的内容。

关于this指向及...操作符以后会陆续讲解。



### 3.bind

https://github.com/zloirock/core-js/blob/master/packages/core-js/internals/function-bind.js

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects

https://tc39.es/ecma262/multipage/abstract-operations.html#sec-call

https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-function.prototype.apply

https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-preparefortailcall

https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html#sec-ecmascript-language-types



[1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#using_slice_to_convert_array-like_objects_to_arrays	"slice 转array-like 对象 为数组"
[2]: https://github.com/zloirock/core-js/blob/master/packages/core-js/internals/function-bind.js	"Core-js中bind 的实现方法"



> 

