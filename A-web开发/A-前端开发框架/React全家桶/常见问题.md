

#### [1.Can't perform a React state update on an unmounted component.](https://stackoverflow.com/questions/53949393/cant-perform-a-react-state-update-on-an-unmounted-component) 

Can't perform a React state update on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in a useEffect cleanup function.

You can declare `let isMounted = true` inside `useEffect`, which will be changed in the [cleanup callback](https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup), as soon as the component is unmounted. Before state updates, you now check this variable conditionally:

```
useEffect(() => {
  let isMounted = true;               // note mutable flag
  someAsyncOperation().then(data => {
    if (isMounted) setState(data);    // add conditional check
  })
  return () => { isMounted = false }; // cleanup toggles value, if unmounted
}, []);                               // adjust dependencies to your needs
```

> https://stackoverflow.com/questions/53949393/cant-perform-a-react-state-update-on-an-unmounted-component

#### 2.https://devtrium.com/posts/async-functions-useeffect

```react
useEffect(() => {
  let isSubscribed = true;

  // declare the async data fetching function
  const fetchData = async () => {
    // get the data from the api
    const data = await fetch(`https://yourapi.com?param=${param}`);
    // convert the data to json
    const json = await response.json();

    // set state with the result if `isSubscribed` is true
    if (isSubscribed) {
      setData(json);
    }
  }

  // call the function
  fetchData()
    // make sure to catch any error
    .catch(console.error);;

  // cancel any future `setData`
  return () => isSubscribed = false;
}, [param])
```



#### 3.function 组件 传ref

#### 4.https://devtrium.com/posts/how-sleep-javascript

#### [5.What is Concurrent React?](https://react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react)

在React中的并发渲染是指React框架对渲染过程进行优化，以提高应用程序的性能和响应能力。传统的React渲染是同步进行的，即在渲染过程中，如果有大量的计算或渲染任务，会导致页面卡顿或失去响应。为了解决这个问题，React引入了并发渲染的概念。

并发渲染允许React将渲染工作分成多个小任务，并将其分配到多个时间片（time slice）中进行处理。这样，每个时间片都可以执行一小部分的渲染工作，然后让出CPU给其他任务，以保证页面的响应性。

在并发渲染中，React使用了一种称为"调度器"（Scheduler）的机制，它负责安排和管理渲染任务的执行。调度器根据优先级和时间片分配策略，将渲染任务划分为多个时间片，并在每个时间片中执行一部分任务。当时间片用尽或有更高优先级的任务需要执行时，调度器会暂停当前任务，切换到下一个任务，以保证任务的平衡分配和页面的响应性。

通过并发渲染，React能够更好地响应用户交互和保持页面的流畅性。它可以将渲染任务分解成更小的单元，提高渲染的并行性和效率。同时，由于React会根据任务的优先级和时间片的分配策略来动态调整任务的执行顺序，所以可以更好地控制任务的执行顺序和优先级，提高应用程序的性能和用户体验。

需要注意的是，并发渲染是React框架的一项高级特性，需要在React 18版本及以上进行使用。在使用并发渲染时，开发者需要注意遵循React的相关规范和最佳实践，以确保应用程序的正确性和性能。

#### 5.`useState` 为对象时，赋值时一定要copy 再赋值

```react
const [a,setA] = useState({})
const [b,setB] = useState({})
setB(a)
//这个赋值不对，对象是引用赋值。 要copy 一份a再赋值
```

